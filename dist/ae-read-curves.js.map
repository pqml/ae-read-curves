{"version":3,"file":"ae-read-curves.js","sources":["../src/index.js"],"sourcesContent":["import bezier from 'bezier-easing'\n\nconst KF_TYPES = {\n  HOLD: 0,\n  LINEAR: 1,\n  BEZIER: 2\n}\n\nconst ERRORS = {\n  badDataObj: () => 'Unable to read curves data object.'\n}\n\nfunction lerp (v0, v1, t) {\n  return v0 * (1 - t) + v1 * t\n}\n\nfunction validateDataObj (data) {\n  if (\n    !data ||\n    data.d === undefined ||\n    data.w === undefined ||\n    data.h === undefined ||\n    data.k === undefined\n  ) {\n    throw new Error(ERRORS.badDataObj)\n  }\n}\n\nfunction readValue (progress, current, next) {\n  if (!next) return current[1] // last item, hold value\n\n  const relProgress = Math.min(Math.max((progress - current[0]) / (next[0] - current[0]), 0), 1)\n  if (current[2] === KF_TYPES.BEZIER) {\n    return lerp(current[1], next[1],current[4](relProgress))\n  } else if (current[2] === KF_TYPES.HOLD) {\n    return current[1]\n  } else if (current[2] === KF_TYPES.LINEAR) {\n    return lerp(current[1], next[1], relProgress)\n  } else {\n    return 0\n  }\n}\n\nfunction readCurve (progress, data, key, cache) {\n  if (isNaN(progress)) progress = 0\n  progress = Math.min(Math.max(progress, 0), 1)\n\n  const cacheIndex = cache[key]\n  const cached = data[cacheIndex]\n\n  if (progress === cached[0]) {\n    return readValue(progress, cached, data[cacheIndex + 1])\n  }\n\n  const direction = progress >= cached[0] ? 1 : -1\n  let currentIndex = cacheIndex\n  let current = cached\n  const lastIndex = data.length - 1\n\n  // bounds check\n  if (progress <= data[0][0]) {\n    cache[key] = 0\n    return data[0][1]\n  } else if (progress >= data[lastIndex][0]) {\n    cache[key] = lastIndex\n    return data[lastIndex][1]\n  }\n\n  // look for next value from cached one\n  while (true) {\n    let nextIndex = currentIndex + direction\n    let next = data[nextIndex]\n    if (direction === 1 && (next === undefined || next[0] > progress)) {\n      cache[key] = currentIndex\n      return readValue(progress, current, data[currentIndex + 1])\n    } else if (direction === -1 && (next === undefined || next[0] <= progress)) {\n      if (nextIndex < 0) {\n        nextIndex = 0\n        next = data[0]\n      }\n      cache[key] = nextIndex\n      return readValue(progress, next, data[nextIndex + 1])\n    }\n    currentIndex = nextIndex\n    current = next\n  }\n}\n\nfunction generateEasings (props) {\n  for (let prop in props) {\n    const keyframes = props[prop]\n    keyframes.map(point => {\n      if (!point[3]) return point\n      point[4] = bezier(point[3][0], point[3][1], point[3][2], point[3][3])\n    })\n  }\n}\n\nfunction readCurves (rawdata = {}, opts = {}) {\n  // deep copy data\n  const data = JSON.parse(JSON.stringify(rawdata))\n\n  validateDataObj(data)\n\n  const duration = data.d\n  const width = data.w\n  const height = data.h\n  const props = data.k\n\n  if (opts.props) {\n    for (let prop in props) {\n      if (!~opts.props.indexOf(prop)) delete props[prop]\n    }\n  }\n\n  const val = {}\n  const cache = {}\n  for (let prop in props) cache[prop] = 0 // create cache\n\n  generateEasings(props)\n  seek(0)\n  return { seek, val, values: val, v: val, duration, width, height }\n\n  function seek (progress = 0) {\n    for (let prop in props) val[prop] = readCurve(progress, props[prop], prop, cache)\n  }\n}\n\nexport default readCurves\n"],"names":["KF_TYPES","HOLD","LINEAR","BEZIER","ERRORS","badDataObj","lerp","v0","v1","t","readValue","progress","current","next","const","relProgress","Math","min","max","readCurve","data","key","cache","isNaN","cacheIndex","cached","direction","currentIndex","lastIndex","length","let","nextIndex","undefined","rawdata","opts","JSON","parse","stringify","d","w","h","k","Error","validateDataObj","duration","width","height","props","prop","indexOf","val","map","point","bezier","generateEasings","seek","values","v"],"mappings":"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"}