{"version":3,"file":"ae-read-curves.umd.js","sources":["../node_modules/bezier-easing/src/index.js","../src/index.js"],"sourcesContent":["/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\n\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\nfunction B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\nfunction C (aA1)      { return 3.0 * aA1; }\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }\n\nfunction binarySubdivide (aX, aA, aB, mX1, mX2) {\n  var currentX, currentT, i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\n\nfunction newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {\n for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n   var currentSlope = getSlope(aGuessT, mX1, mX2);\n   if (currentSlope === 0.0) {\n     return aGuessT;\n   }\n   var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n   aGuessT -= currentX / currentSlope;\n }\n return aGuessT;\n}\n\nmodule.exports = function bezier (mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  // Precompute samples table\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  if (mX1 !== mY1 || mX2 !== mY2) {\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  function getTForX (aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing (x) {\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x; // linear\n    }\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};\n","import bezier from 'bezier-easing'\n\nconst KF_TYPES = {\n  HOLD: 0,\n  LINEAR: 1,\n  BEZIER: 2\n}\n\nconst ERRORS = {\n  badDataObj: () => 'Unable to read curves data object.'\n}\n\nfunction lerp (v0, v1, t) {\n  return v0 * (1 - t) + v1 * t\n}\n\nfunction validateDataObj (data) {\n  if (\n    !data ||\n    data.d === undefined ||\n    data.w === undefined ||\n    data.h === undefined ||\n    data.k === undefined\n  ) {\n    throw new Error(ERRORS.badDataObj)\n  }\n}\n\nfunction readValue (progress, current, next) {\n  if (!next) return current[1] // last item, hold value\n\n  const relProgress = Math.min(Math.max((progress - current[0]) / (next[0] - current[0]), 0), 1)\n  if (current[2] === KF_TYPES.BEZIER) {\n    return lerp(current[1], next[1],current[4](relProgress))\n  } else if (current[2] === KF_TYPES.HOLD) {\n    return current[1]\n  } else if (current[2] === KF_TYPES.LINEAR) {\n    return lerp(current[1], next[1], relProgress)\n  } else {\n    return 0\n  }\n}\n\nfunction readCurve (progress, data, key, cache) {\n  if (isNaN(progress)) progress = 0\n  progress = Math.min(Math.max(progress, 0), 1)\n\n  const cacheIndex = cache[key]\n  const cached = data[cacheIndex]\n\n  if (progress === cached[0]) {\n    return readValue(progress, cached, data[cacheIndex + 1])\n  }\n\n  const direction = progress >= cached[0] ? 1 : -1\n  let currentIndex = cacheIndex\n  let current = cached\n  const lastIndex = data.length - 1\n\n  // bounds check\n  if (progress <= data[0][0]) {\n    cache[key] = 0\n    return data[0][1]\n  } else if (progress >= data[lastIndex][0]) {\n    cache[key] = lastIndex\n    return data[lastIndex][1]\n  }\n\n  // look for next value from cached one\n  while (true) {\n    let nextIndex = currentIndex + direction\n    let next = data[nextIndex]\n    if (direction === 1 && (next === undefined || next[0] > progress)) {\n      cache[key] = currentIndex\n      return readValue(progress, current, data[currentIndex + 1])\n    } else if (direction === -1 && (next === undefined || next[0] <= progress)) {\n      if (nextIndex < 0) {\n        nextIndex = 0\n        next = data[0]\n      }\n      cache[key] = nextIndex\n      return readValue(progress, next, data[nextIndex + 1])\n    }\n    currentIndex = nextIndex\n    current = next\n  }\n}\n\nfunction generateEasings (props) {\n  for (let prop in props) {\n    const keyframes = props[prop]\n    keyframes.map(point => {\n      if (!point[3]) return point\n      point[4] = bezier(point[3][0], point[3][1], point[3][2], point[3][3])\n    })\n  }\n}\n\nfunction readCurves (rawdata = {}, opts = {}) {\n  // deep copy data\n  const data = JSON.parse(JSON.stringify(rawdata))\n\n  validateDataObj(data)\n\n  const duration = data.d\n  const width = data.w\n  const height = data.h\n  const props = data.k\n\n  if (opts.props) {\n    for (let prop in props) {\n      if (!~opts.props.indexOf(prop)) delete props[prop]\n    }\n  }\n\n  const val = {}\n  const cache = {}\n  for (let prop in props) cache[prop] = 0 // create cache\n\n  generateEasings(props)\n  seek(0)\n  return { seek, val, values: val, v: val, duration, width, height }\n\n  function seek (progress = 0) {\n    for (let prop in props) val[prop] = readCurve(progress, props[prop], prop, cache)\n  }\n}\n\nexport default readCurves\n"],"names":["NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","kSplineTableSize","kSampleStepSize","float32ArraySupported","Float32Array","A","aA1","aA2","B","C","calcBezier","aT","getSlope","mX1","mY1","mX2","mY2","Error","sampleValues","Array","i","getTForX","aX","intervalStart","currentSample","lastSample","guessForT","initialSlope","aGuessT","currentSlope","newtonRaphsonIterate","aA","aB","currentX","currentT","Math","abs","binarySubdivide","x","KF_TYPES","HOLD","LINEAR","BEZIER","ERRORS","badDataObj","lerp","v0","v1","t","readValue","progress","current","next","const","relProgress","min","max","readCurve","data","key","cache","isNaN","cacheIndex","cached","direction","currentIndex","lastIndex","length","let","nextIndex","undefined","rawdata","opts","JSON","parse","stringify","d","w","h","k","validateDataObj","duration","width","height","props","prop","indexOf","val","map","point","bezier","generateEasings","seek","values","v"],"mappings":"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"}